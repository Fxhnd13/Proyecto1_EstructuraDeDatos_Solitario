        if(cantidadDeCartasValida(pilaSalida, cantidad)){//agrega las cartas a la pila auxiliar
            for (int i = 0; i < cantidad; i++){
                Carta carta = pilaSalida->carta;
                sacarCarta(pilaSalida);
                agregarCarta(aux, carta);
            }
        }
        if(colDestino<8){//si se desea mover a una de las pilas del juego (no ordenadas por tipo)
            if(compatiblesJuego(aux->carta.getTipo(), pilaDestino->carta.getTipo())){//deben ser del mismo tipo
                if(isEmpty(pilaDestino)){//si la pila destino esta vacia
                    if((aux->carta).getValor()==13){//si no se hay una carta Rey primero no se puede hacer el movimiento
                        while(!isEmpty(aux)){
                            Carta carta = aux->carta;
                            sacarCarta(aux);
                            agregarCarta(pilaDestino, carta);
                            huboMovimiento = true;
                        }
                    }else{//si no se puede hacer elmovimiento regresamos todas las cartas de auxiliar a pilaSalida
                        while(!isEmpty(aux)){
                            Carta carta = aux->carta;
                            sacarCarta(aux);
                            agregarCarta(pilaSalida, carta);
                        }
                    }
                }else{//si no esta vacia la pila destino
                    if((aux->carta).getValor()<(pilaDestino->carta).getValor()){//verifica que el valor de pilaDestino sea mayor que el valor de la carta al tope de auxiliar
                        while(!isEmpty(aux)){
                            Carta carta = aux->carta;
                            sacarCarta(aux);
                            agregarCarta(pilaDestino, carta);
                            huboMovimiento=true;
                        }
                    }else{//de lo contrario regresamos todas las cartas de aux a pilaSalida
                        while(!isEmpty(aux)){
                            Carta carta = aux->carta;
                            sacarCarta(aux);
                            agregarCarta(pilaSalida, carta);
                        }
                    }
                }
            }else{//si las cartas no son compatibles se regresan todas las cartas de aux a pilaSalida
                cout<<"No se puede realizar el movimiento porque no se pueden poner cartas rojas o negras consecutivas.";
                while(!isEmpty(aux)){
                    Carta carta = aux->carta;
                    sacarCarta(aux);
                    agregarCarta(pilaSalida, carta);
                }
            }
        }else{
            int tipoDestino;
            if(colDestino==8)tipoDestino=0;
            if(colDestino==9)tipoDestino=1;
            if(colDestino==10)tipoDestino=2;
            if(colDestino==11)tipoDestino=3;
            if((aux->carta).getTipo()==tipoDestino){
                if(isEmpty(pilaDestino)){//si la pila esta vacia
                    if(aux->carta.getValor()==1){//la carta a apilar debe ser un As
                        Carta carta = aux->carta;
                        sacarCarta(aux);
                        agregarCarta(pilaDestino, carta);
                        huboMovimiento=true;
                    }else{//de no ser un As la colocamos de nuevo donde estaba
                        Carta carta = aux->carta;
                        sacarCarta(aux);
                        agregarCarta(pilaSalida, carta);
                    }
                }else{//si la pila no esta vacia
                    if((pilaDestino->carta).getValor()<(aux->carta).getValor()){//verificamos que la carta en el tope de pilaDestino sea mayor a la carta en aux
                        Carta carta = aux->carta;
                        sacarCarta(aux);
                        agregarCarta(pilaDestino, carta);
                        huboMovimiento = true;
                    }else{//de lo contrario regresamos todas las cartas de aux a pilaSalida
                        Carta carta = aux->carta;
                        sacarCarta(aux);
                        agregarCarta(pilaSalida, carta);
                    }
                }
            }else{
                cout<<"No se puede realizar el movimiento porque no se pueden poner cartas de diferente tipo";
                while(!isEmpty(aux)){
                    Carta carta = aux->carta;
                    sacarCarta(aux);
                    agregarCarta(pilaSalida, carta);
                }
            }
        }












        if(colDestino>7){//si se quiere mover a una de las pilas ordenadas
            int tipoDestino;
            switch(colDestino){
                case 8: tipoDestino = 0; break;
                case 9: tipoDestino = 1; break;
                case 10: tipoDestino = 2; break;
                case 11: tipoDestino = 3; break;
            }
            if(cantidad==1){
                if(aux->carta.getTipo()==tipoDestino){
                    if(isEmpty(pilaDestino)){//si la pila destino esta vacia
                        if(aux->carta.getValor()==1){//si la carta es un As se apila
                            Carta carta = aux->carta;
                            sacarCarta(aux);
                            agregarCarta(pilaDestino, carta);
                            huboMovimiento = true;
                        }else{//si la carta no es una as
                            cout<<"No se puede mover una carta que no sea un As a una pila ordenada vacia.";
                            Carta carta = aux->carta;
                            sacarCarta(aux);
                            agregarCarta(pilaSalida, carta);
                        }
                    }else{
                        if(aux->carta.getValor()>pilaDestino->carta.getValor()){
                            Carta carta = aux->carta;
                            sacarCarta(aux);
                            agregarCarta(pilaDestino, carta);
                            huboMovimiento = true;
                        }else{
                            cout<<"No se puede mover una carta que es menor a la pila.";
                            Carta carta = aux->carta;
                            sacarCarta(aux);
                            agregarCarta(pilaSalida, carta);
                        }
                    }
                }else{
                    cout<<"No se puede mover la carta a las pilas ordenadas no son del mismo tipo.";
                    Carta carta = aux->carta;
                    sacarCarta(aux);
                    agregarCarta(pilaSalida, carta);
                }
            }else{
                cout<<"No se puede mover mas de una carta a las pilas ordenadas.";
                while(!isEmpty(aux)){
                    Carta carta = aux->carta;
                    sacarCarta(aux);
                    agregarCarta(pilaSalida, carta);
                }
            }
        }else{//si se quiere mover a una de las pilas del juego principal
            
        }